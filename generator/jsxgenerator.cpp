/****************************************************************************
**
** Copyright (C) 2013 Digia Plc and/or its subsidiary(-ies).
** Contact: http://www.qt-project.org/legal
**
** This file is part of the Qt Script Generator project on Qt Labs.
**
** $QT_BEGIN_LICENSE:LGPL$
** Commercial License Usage
** Licensees holding valid commercial Qt licenses may use this file in
** accordance with the commercial license agreement provided with the
** Software or, alternatively, in accordance with the terms contained in
** a written agreement between you and Digia.  For licensing terms and
** conditions see http://qt.digia.com/licensing.  For further information
** use the contact form at http://qt.digia.com/contact-us.
**
** GNU Lesser General Public License Usage
** Alternatively, this file may be used under the terms of the GNU Lesser
** General Public License version 2.1 as published by the Free Software
** Foundation and appearing in the file LICENSE.LGPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU Lesser General Public License version 2.1 requirements
** will be met: http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.
**
** In addition, as a special exception, Digia gives you certain additional
** rights.  These rights are described in the Digia Qt LGPL Exception
** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.
**
** GNU General Public License Usage
** Alternatively, this file may be used under the terms of the GNU
** General Public License version 3.0 as published by the Free Software
** Foundation and appearing in the file LICENSE.GPL included in the
** packaging of this file.  Please review the following information to
** ensure the GNU General Public License version 3.0 requirements will be
** met: http://www.gnu.org/copyleft/gpl.html.
**
**
** $QT_END_LICENSE$
**
****************************************************************************/

#include "jsxgenerator.h"
#include "fileout.h"
#include <iostream>

QList<int> uniqueEnumValueIndexes(const AbstractMetaEnumValueList &values);

JSXGenerator::JSXGenerator()
{
    _ignoreFileList.insert("long");
    _ignoreFileList.insert("intlist");
    _ignoreFileList.insert("qhttpresponseheader");
    _ignoreFileList.insert("qstring");
    _ignoreFileList.insert("qlist");
    _ignoreFileList.insert("qstringlist");
    _ignoreFileList.insert("qvariant");
    _ignoreFileList.insert("qnoimplicitboolcast");
    _ignoreFileList.insert("qvarlengtharray");
    _ignoreFileList.insert("qpair");
    _ignoreFileList.insert("qvector");
    _ignoreFileList.insert("qtconcurrentreducekernel");
    _ignoreFileList.insert("qtconcurrentthreadengine");
    _ignoreFileList.insert("qgenericmatrix");
    _ignoreFileList.insert("qabstracttextdocumentlayout");
    _ignoreFileList.insert("qprinterinfo");
    _ignoreFileList.insert("qtextoption");
    _ignoreFileList.insert("qcoreevent");

    addRelatedFile("qrect", "qrectf");
    addRelatedFile("qpoint", "qpointf");
    addRelatedFile("qsize", "qsizef");
    addRelatedFile("qline", "qlinef");
    addRelatedFile("qpolygon", "qpolygonf");
}

QString JSXGenerator::fileNameForClass(const AbstractMetaClass *meta_class) const
{
    return QString::fromLatin1("%0.jsx").arg(meta_class->name().toLower());
}

QString JSXGenerator::subDirectoryForClass(const AbstractMetaClass*) const
{
    return "jsx/qt/";
}

static void writeSourceHeader(QTextStream &s, const QString &title)
{
    s << "/*" << endl
      << " * JSX wrapper code generated by JSXgenerator." << endl
      << " *" << endl
      << " * " << title << endl
      << " *" << endl
      << " * Note: DO NOT EDIT THIS FILE" << endl
      << " */" << endl;
}

void JSXGenerator::addRelatedFile(QString target, QString relatedfile)
{
    if (_relatedFileList.contains(target))
    {
        _relatedFileList.value(target)->append(relatedfile);
    }
    else
    {
        QStringList* list = new QStringList;
        list->append(relatedfile);
        _relatedFileList[target] = list;
    }
}

static bool classLessThan(const AbstractMetaClass *c1, const AbstractMetaClass *c2)
{
    return c1->name() < c2->name();
}

static void writeInclude(QTextStream &stream, const QString filename)
{
    stream << "import \"qt/" << filename << ".jsx\";" << endl;
}

static void addIncludeFile(QSet<QString> &includes, QString name)
{
    if (name.endsWith("[]"))
    {
        name.chop(2);
    }
    switch (name.count("_"))
    {
    case 0:
        includes.insert(name.toLower());
        break;
    case 1:
        if (name.startsWith("Qt_"))
        {
            includes.insert("qt");
        }
        else
        {
            includes.insert(name.toLower());
        }
        break;
    case 2:
        if (name.startsWith("Qt_"))
        {
            name.remove(0, 3);
            includes.insert(name.left(name.indexOf("_")).toLower());
        }
        break;
    }
}

bool JSXGenerator::shouldGenerate(const AbstractMetaClass *meta_class) const
{
    uint cg = meta_class->typeEntry()->codeGeneration();
    return (cg & TypeEntry::GenerateCode) != 0;
}

void JSXGenerator::generate()
{
    Generator::generate();

    QHash<QString, QList<const AbstractMetaClass*> > packHash;
    for (int i = 0; i < m_classes.size(); ++i) {
        const AbstractMetaClass *cls = m_classes.at(i);
        if (shouldGenerate(cls))
        {
            packHash[cls->package()].append(cls);
        }
    }
    {
        // package pages
        QHash<QString, QList<const AbstractMetaClass*> >::const_iterator it;
        for (it = packHash.constBegin(); it != packHash.constEnd(); ++it) {
            QString package = it.key();
            QList<const AbstractMetaClass*> classesInPackage = it.value();
            qSort(classesInPackage.begin(), classesInPackage.end(), classLessThan);

            QString packageName = QStringList(package.split(".").mid(2)).join("_");
            FileOut file(m_out_dir + "/jsx/" + packageName + ".jsx");

            writeSourceHeader(file.stream, package + " Package");

            for (int i = 0; i < classesInPackage.size(); ++i) {
                const AbstractMetaClass *cls = classesInPackage.at(i);
                if (cls->name() == "Global")
                    continue; /// ### fixme
                QString fileName = fileNameForClass(cls);
                file.stream << "import \"qt/" << fileName << "\"; // " << cls->name() << endl;
            }
        }
    }

    {
        // signal page
        FileOut file(m_out_dir + "/jsx/qt/_signals.jsx");
        writeSourceHeader(file.stream, "Signals");

        writeInclude(file.stream, "qabstractanimation");
        writeInclude(file.stream, "qabstractbutton");
        writeInclude(file.stream, "qabstractitemdelegate");
        writeInclude(file.stream, "qabstractsocket");
        writeInclude(file.stream, "qaction");
        writeInclude(file.stream, "qbrush");
        writeInclude(file.stream, "qcolor");
        writeInclude(file.stream, "qclipboard");
        writeInclude(file.stream, "qdoublevalidator");
        writeInclude(file.stream, "qdate");
        writeInclude(file.stream, "qdockwidget");
        writeInclude(file.stream, "qfont");
        writeInclude(file.stream, "qgraphicsitem");
        writeInclude(file.stream, "qgraphicsblureffect");
        writeInclude(file.stream, "qheaderview");
        writeInclude(file.stream, "qicon");
        writeInclude(file.stream, "qimagereader");
        writeInclude(file.stream, "qitemselection");
        writeInclude(file.stream, "qlistwidgetitem");
        writeInclude(file.stream, "qlocalsocket");
        writeInclude(file.stream, "qmdisubwindow");
        writeInclude(file.stream, "qmodelindex");
        writeInclude(file.stream, "qmovie");
        writeInclude(file.stream, "qnetworkproxy");
        writeInclude(file.stream, "qauthenticator");
        writeInclude(file.stream, "qnetworkaccessmanager");
        writeInclude(file.stream, "qnetworkreply");
        writeInclude(file.stream, "qnetworkrequest");
        writeInclude(file.stream, "qobject");
        writeInclude(file.stream, "qpoint");
        writeInclude(file.stream, "qpointf");
        writeInclude(file.stream, "qprinter");
        writeInclude(file.stream, "qprocess");
        writeInclude(file.stream, "qrect");
        writeInclude(file.stream, "qrectf");
        writeInclude(file.stream, "qsessionmanager");
        writeInclude(file.stream, "qsize");
        writeInclude(file.stream, "qsqlrecord");
        writeInclude(file.stream, "qsslerror");
        writeInclude(file.stream, "qsslsocket");
        writeInclude(file.stream, "qstandarditem");
        writeInclude(file.stream, "qsystemtrayicon");
        writeInclude(file.stream, "qtablewidgetitem");
        writeInclude(file.stream, "qtextcharformat");
        writeInclude(file.stream, "qtextcursor");
        writeInclude(file.stream, "qtime");
        writeInclude(file.stream, "qtimeline");
        writeInclude(file.stream, "qtreewidgetitem");
        writeInclude(file.stream, "qundostack");
        writeInclude(file.stream, "qurl");
        writeInclude(file.stream, "qwebframe");
        writeInclude(file.stream, "qwidget");
        writeInclude(file.stream, "qt");

        QMap<QString, QString>::const_iterator it;
        for (it = _signals.constBegin(); it != _signals.constEnd(); ++it) {
            file.stream << "native __fake__ class QtJSX" << it.key() << "Signal {" << endl
                        << "    function connect(callback : ("
                            << it.value() << ") -> void): void;" << endl
                        << "    function disconnect(callback : ("
                            << it.value() << ") -> void): void;" << endl
                        << "}" << endl << endl;
        }
    }

    {
        // hub file
        FileOut file(m_out_dir + "/jsx/qt/qdom.jsx");
        writeSourceHeader(file.stream, "QXML DOM Objects");
        writeInclude(file.stream, "qdomattr");
        writeInclude(file.stream, "qdomnode");
        writeInclude(file.stream, "qdomcharacterdata");
        writeInclude(file.stream, "qdomcomment");
        writeInclude(file.stream, "qdomdocument");
        writeInclude(file.stream, "qdomdocumentfragment");
        writeInclude(file.stream, "qdomdocumenttype");
        writeInclude(file.stream, "qdomelement");
        writeInclude(file.stream, "qdomentityreference");
        writeInclude(file.stream, "qdomimplementation");
        writeInclude(file.stream, "qdomnamednodemap");
        writeInclude(file.stream, "qdomnodelist");
        writeInclude(file.stream, "qdomprocessinginstruction");
        writeInclude(file.stream, "qdomtext");
    }

    {
        // hub file
        FileOut file(m_out_dir + "/jsx/qt/qxml.jsx");
        writeSourceHeader(file.stream, "QXML SAX Objects");
        writeInclude(file.stream, "qxmlattributes");
        writeInclude(file.stream, "qxmlcontenthandler");
        writeInclude(file.stream, "qxmldeclhandler");
        writeInclude(file.stream, "qxmldtdhandler");
        writeInclude(file.stream, "qxmlentityresolver");
        writeInclude(file.stream, "qxmlerrorhandler");
        writeInclude(file.stream, "qxmlinputsource");
        writeInclude(file.stream, "qxmllexicalhandler");
    }

    {
        // hub file
        FileOut file(m_out_dir + "/jsx/qt/qxmlstream.jsx");
        writeSourceHeader(file.stream, "QXML Stream Objects");
        writeInclude(file.stream, "qxmlstreamattribute");
        writeInclude(file.stream, "qxmlstreamattributes");
        writeInclude(file.stream, "qxmlstreamentityresolver");
        writeInclude(file.stream, "qxmlstreamreader");
        writeInclude(file.stream, "qxmlstreamentitydeclaration");
        writeInclude(file.stream, "qxmlstreamnamespacedeclaration");
        writeInclude(file.stream, "qxmlstreamnotationdeclaration");
    }

    {
        // hub file
        FileOut file(m_out_dir + "/jsx/qt/qgl.jsx");
        writeSourceHeader(file.stream, "QOpenGL Objects");
        writeInclude(file.stream, "qglcontext");
        writeInclude(file.stream, "qglshader");
    }

    {
        // hub file
        FileOut file(m_out_dir + "/jsx/qt/qvariant.jsx");
        writeSourceHeader(file.stream, "QVariant class");
        file.stream << endl
            << "native __fake__ class Qt_QVariant_Type {}" << endl
            << "native class QVariant {" << endl
            << "    static const Invalid : Qt_QVariant_Type;" << endl
            << "    static const BitArray : Qt_QVariant_Type;" << endl
            << "    static const Bitmap : Qt_QVariant_Type;" << endl
            << "    static const Bool : Qt_QVariant_Type;" << endl
            << "    static const Brush : Qt_QVariant_Type;" << endl
            << "    static const ByteArray : Qt_QVariant_Type;" << endl
            << "    static const Char : Qt_QVariant_Type;" << endl
            << "    static const Color : Qt_QVariant_Type;" << endl
            << "    static const Cursor : Qt_QVariant_Type;" << endl
            << "    static const Date : Qt_QVariant_Type;" << endl
            << "    static const DateTime : Qt_QVariant_Type;" << endl
            << "    static const Double : Qt_QVariant_Type;" << endl
            << "    static const EasingCurve : Qt_QVariant_Type;" << endl
            << "    static const Font : Qt_QVariant_Type;" << endl
            << "    static const Hash : Qt_QVariant_Type;" << endl
            << "    static const Icon : Qt_QVariant_Type;" << endl
            << "    static const Image : Qt_QVariant_Type;" << endl
            << "    static const Int : Qt_QVariant_Type;" << endl
            << "    static const KeySequence : Qt_QVariant_Type;" << endl
            << "    static const Line : Qt_QVariant_Type;" << endl
            << "    static const LineF : Qt_QVariant_Type;" << endl
            << "    static const List : Qt_QVariant_Type;" << endl
            << "    static const Locale : Qt_QVariant_Type;" << endl
            << "    static const LongLong : Qt_QVariant_Type;" << endl
            << "    static const Map : Qt_QVariant_Type;" << endl
            << "    static const Matrix : Qt_QVariant_Type;" << endl
            << "    static const Transform : Qt_QVariant_Type;" << endl
            << "    static const Matrix4x4 : Qt_QVariant_Type;" << endl
            << "    static const Palette : Qt_QVariant_Type;" << endl
            << "    static const Pen : Qt_QVariant_Type;" << endl
            << "    static const Pixmap : Qt_QVariant_Type;" << endl
            << "    static const Point : Qt_QVariant_Type;" << endl
            << "    static const PointArray : Qt_QVariant_Type;" << endl
            << "    static const PointF : Qt_QVariant_Type;" << endl
            << "    static const Polygon : Qt_QVariant_Type;" << endl
            << "    static const Quaternion : Qt_QVariant_Type;" << endl
            << "    static const Rect : Qt_QVariant_Type;" << endl
            << "    static const RectF : Qt_QVariant_Type;" << endl
            << "    static const RegExp : Qt_QVariant_Type;" << endl
            << "    static const Region : Qt_QVariant_Type;" << endl
            << "    static const Size : Qt_QVariant_Type;" << endl
            << "    static const SizeF : Qt_QVariant_Type;" << endl
            << "    static const SizePolicy : Qt_QVariant_Type;" << endl
            << "    static const String : Qt_QVariant_Type;" << endl
            << "    static const StringList : Qt_QVariant_Type;" << endl
            << "    static const TextFormat : Qt_QVariant_Type;" << endl
            << "    static const TextLength : Qt_QVariant_Type;" << endl
            << "    static const Time : Qt_QVariant_Type;" << endl
            << "    static const UInt : Qt_QVariant_Type;" << endl
            << "    static const ULongLong : Qt_QVariant_Type;" << endl
            << "    static const Url : Qt_QVariant_Type;" << endl
            << "    static const Vector2D : Qt_QVariant_Type;" << endl
            << "    static const Vector3D : Qt_QVariant_Type;" << endl
            << "    static const Vector4D : Qt_QVariant_Type;" << endl
            << "    static const UserType : Qt_QVariant_Type;" << endl
            << "}" << endl;
    }
}

static bool shouldIgnoreEnum(const AbstractMetaEnum *enom)
{
    return !enom->wasPublic() || (enom->name() == "enum_1");
}

static bool skipType(QString& type)
{
    return (type.contains("QPair") || type.contains("QMap") ||
            type.contains("QHash") || type.contains("QSet") ||
            type.contains("QMultiMap") || type == "QGLFormat" ||
            type.contains("QWebHistory") || type == "QAbstractFileEngine" ||
            type == "QThread" || type == "QInputMethodEvent" || type == "WId" ||
            type == "quintptr" || type == "QPrinterInfo" || type == "QGraphicsEffectSource" ||
            type == "QIconEngineV2" || type.contains("QTextOption") ||
            type.contains("QAbstractTextDocumentLayout") || type.contains("QGraphicsItem_Extension") ||
            type == "Qt_HANDLE" || type.startsWith("QWebPluginFactory") ||
            type.endsWith("iterator") || type == "Qt_QAbstractItemView_CursorAction" ||
            type == "Qt_QAbstractSlider_SliderChange" || type.startsWith("Qt_QTextLayout_FormatRange") ||
            type == "Qt_QPainterPath_Element" || type == "Qt_QTextCodec_ConverterState" ||
            type == "Qt_QAbstractItemView_DropIndicatorPosition" || type == "Qt_QAbstractItemView_State" ||
            type == "QAbstractProxyModel" || type == "Qt_QFontDatabase_WritingSystem" ||
            type == "Qt_QTextEdit_ExtraSelection[]" || type == "Qt_QSqlResult_BindingSyntax");
}

static bool skipMethod(const AbstractMetaClass* meta_class, const AbstractMetaFunction* func)
{
    QString classname = meta_class->name();
    QString methodname = func->modifiedName();
    if (classname == "QWidget")
    {
        return (methodname == "windowOpacity" || methodname == "setWindowOpacity");
    }
    else if (classname == "QAbstractSocket" || classname == "QProcess" || classname == "QNetworkReply" || classname == "QLocalSocket")
    {
        return (methodname == "error");
    }
    else if (classname == "QDockWidget")
    {
        return (methodname == "allowedAreas" || methodname == "setAllowedAreas");
    }
    else if (classname == "QSslSocket")
    {
        return (methodname == "sslErrors");
    }
    else if (classname == "QSvgGenerator" || classname == "QSvgRenderer")
    {
        return (methodname == "viewBox" || methodname == "setViewBox");
    }
    else if (classname == "QByteArray")
    {
        return (methodname == "replace" && func->arguments().at(0)->argumentName() == "c");
    }
    else if (classname == "QFontMetrics")
    {
        return (methodname == "boundingRect" && func->arguments().at(0)->argumentName() == "arg__1");
    }
    else if (classname == "QFontMetricsF")
    {
        if (methodname == "boundingRect" || methodname == "width")
        {
            return (func->arguments().at(0)->argumentName() == "arg__1");
        }
    }
    else if (methodname == "minimumSizeHint" || methodname == "sizeHint")
    {
        return (classname != "QWidget");
    }
    else if (methodname == "spacing")
    {
        return (classname == "QBoxLayout" || classname == "QGridLayout" || classname == "QFormLayout");
    }
    return (methodname == "toString");
}

static bool skipProperty(const AbstractMetaClass* meta_class, const QPropertySpec *prop)
{
    QString classname = meta_class->name();
    QString propname = prop->name();
    if (propname == "duration")
    {
        return (classname == "QPauseAnimation" || classname == "QVariantAnimation");
    }
    else if (classname == "QDockWidget")
    {
        return (propname == "windowTitle");
    }
    else if (classname == "QDialog")
    {
        return (propname == "modal");
    }
    else if (classname == "QPrintDialog")
    {
        return (propname == "accepted");
    }
    else if (classname == "QCommandLinkButton")
    {
        return (propname == "flat");
    }
    else if (classname == "VideoWidget")
    {
        return (propname == "fullScreen");
    }
    return false;
}

void filterFunctions(
    const AbstractMetaClass *meta_class,
    QMap<QString, AbstractMetaFunctionList> &prototypeFunctions,
    QMap<QString, AbstractMetaFunctionList> &staticFunctions,
    QMap<QString, AbstractMetaFunctionList> &signalFunctions,
    QMap<QString, AbstractMetaFunctionList> &slotFunctions
    )
{
    AbstractMetaFunctionList functions = meta_class->functionsInTargetLang() + meta_class->cppSignalFunctions();
    for (int i = 0; i < functions.size(); ++i) {
        AbstractMetaFunction* func = functions.at(i);
        if (func->declaringClass() != meta_class)
            continue; // function inherited through prototype
        if (func->isSignal())
        {
            signalFunctions[func->originalName()].append(func);
            continue;
        }
        if (!func->isNormal())
            continue;
#ifdef GENERATOR_NO_PROTECTED_FUNCTIONS
        if (func->wasProtected())
            continue;
#endif
        if (func->isPropertyReader() || func->isPropertyWriter())
            continue; // no point in including property accessors
        //if (func->isInvokable())
        //    continue; // no point in including signals and slots
        else if (func->isSlot())
        {
            slotFunctions[func->modifiedName()].append(func);
        }
        else if (func->isStatic())
        {
            staticFunctions[func->modifiedName()].append(func);
        }
        else
        {
            prototypeFunctions[func->modifiedName()].append(func);
        }
    }
}

static QString normalizedType(QString str, bool forArg = true)
{
    if (str.contains("char*"))
    {
        str = "string";
    }
    else if (str.endsWith("**"))
    {
        str.chop(2);
        str = str + "[]";
    }
    else if (str.endsWith("*"))
    {
        str.chop(1);
    }
    if (str.startsWith("QList<"))
    {
        str.remove(0, 6);
        str = str.left(str.lastIndexOf(">")).trimmed();
        if (str.endsWith("*"))
        {
            str.chop(1);
        }
        str = str + (forArg ? "[]" : "List");
    }
    else if (str.startsWith("QVector<"))
    {
        str.remove(0, 8);
        str = str.left(str.lastIndexOf(">")).trimmed();
        if (str.endsWith("*"))
        {
            str.chop(1);
        }
        str = str + (forArg ? "[]" : "List");
    }
    else if (str.startsWith("QFlags<"))
    {
        str.remove(0, 7);
        str = str.left(str.lastIndexOf(">")).trimmed();
        if (str == "Qt::WindowType")
        {
            str = "Qt::WindowFlags";
        }
        else if (str.endsWith("ty"))
        {
            str.chop(1);
            str = str + "ies";
        }
        else
        {
            str = str + "s";
        }
    }
    if (str.contains("::"))
    {
        str = str.replace("::", "_");
        if (!str.startsWith("Qt_"))
        {
            str.insert(0, "Qt_");
        }
    }
    else if (str == QLatin1String("QBool")) // ### hack
        str = QLatin1String("boolean");
    return str;
}

static QString normalizedType(const AbstractMetaType *type, bool forArg = true)
{
    QString str = QString::fromLatin1(QMetaObject::normalizedType(type->cppSignature().toLatin1()));
    if (str.endsWith(QLatin1Char('&')))
        str.chop(1);
    else if (str.startsWith("const ")) {
        if (str.endsWith('*') || type->hasInstantiations() || type->typeEntry()->isValue())
            str.remove(0, 6);
    }
    return normalizedType(str, forArg);
}

static void writeFunction(QTextStream &o, const AbstractMetaFunction *fun, QMap<QString, QString> &nativeTypes, QSet<QString> &existingMethods, QSet<QString>& includes, bool isStatic = false)
{
    QMap<QString, QString> keywords;
    keywords["in"] = "in_";
    keywords["var"] = "var_";

    QTextStream s("", QIODevice::ReadWrite);
    if (isStatic)
    {
        s << "    static function ";
    }
    else
    {
        s << "    function ";
    }

    // Attributes...

    if (fun->isConstructor())
    {
        s << "constructor";
    }
    else
    {
        s << fun->modifiedName();
    }
    s << " (";

    int j = 0;
    for (int i=0; i< fun->arguments().size(); ++i) {
        if (fun->argumentRemoved(i+1))
            continue;
        if (j != 0) {
            s << "," << QLatin1Char(' ');
        }
        QString type = normalizedType(fun->arguments().at(i)->type());
        // QtScript binding can't treat QPair
        if (skipType(type))
        {
            return;
        }
        QString varname = fun->arguments().at(i)->argumentName();
        QString finaltype = nativeTypes.value(type, type);
        s << keywords.value(varname, varname) << " : " << finaltype;
        addIncludeFile(includes, finaltype);
        ++j;
    }
    if (fun->isConstructor())
    {
        s << ");" << endl;
    }
    else
    {
        s << ") : ";
        // Return type
        if (fun->type()) {
            QString sig = normalizedType(fun->type());
            // QtScript binding can't treat QPair
            if (skipType(sig))
            {
                return;
            }
            QString finalsig = nativeTypes.value(sig, sig);
            s << finalsig << ";" << endl;
            addIncludeFile(includes, finalsig);
        } else {
            s << "void;" << endl;
        }
    }
    s.seek(0);
    QString definition = s.readAll();
    if (!existingMethods.contains(definition))
    {
        o << definition;
        existingMethods.insert(definition);
    }
}

static void writeSignal(QTextStream &s, const AbstractMetaClass *meta_class, const AbstractMetaFunctionList &funs, QMap<QString, QString> &nativeTypes, QMap<QString, QString> &signalFunctions, QSet<QString> &includes, QStringList &signalAliases)
{
    AbstractMetaFunction* shortestfun = 0;
    int length = 10000;
    QString signalNameString;
    QString signalArgsString;
    AbstractMetaFunctionList::const_iterator it;
    for (it = funs.constBegin(); it != funs.constEnd(); ++it) {
        AbstractMetaFunction* fun = *it;
        QTextStream signalName("", QIODevice::ReadWrite);
        QTextStream signalArgs("", QIODevice::ReadWrite);
        int j = 0;
        for (int i=0; i< fun->arguments().size(); ++i) {
            if (fun->argumentRemoved(i+1))
                continue;
            if (j != 0) {
                signalArgs << "," << QLatin1Char(' ');
            }
            QString type = normalizedType(fun->arguments().at(i)->type(), false);
            // QtScript binding can't treat QPair
            if (skipType(type))
            {
                return;
            }
            QString name = type;
            signalName << name.replace(' ', '_');
            QString finaltype = nativeTypes.value(type, type);
            signalArgs << finaltype;
            addIncludeFile(includes, finaltype);
            ++j;
        }
        signalName.seek(0);
        QString tmpSignalNameString = signalName.readAll();
        if (tmpSignalNameString.length() < length)
        {
            signalNameString = tmpSignalNameString;
            signalArgs.seek(0);
            signalArgsString = signalArgs.readAll();
            shortestfun = fun;
        }
    }
    if (shortestfun)
    {
        // JSX can't override property! Now this genertor ignores these properties!
        if (meta_class->name() == "QPrintDialog" && shortestfun->originalName() == "accepted")
        {
            return;
        }
        s << "    var " << shortestfun->originalName();
        s << " : QtJSX";
        s << signalNameString << "Signal;" << endl;
        if (!signalFunctions.contains(signalNameString))
        {
            signalFunctions[signalNameString] = signalArgsString;
        }
        if (funs.length() > 1 && shortestfun->arguments().size() == 1)
        {
            QTextStream alias("", QIODevice::ReadWrite);
            alias << meta_class->name() << ".prototype." << shortestfun->originalName() << " = "
                  << meta_class->name() << ".prototype['" << shortestfun->originalName() << "("
                  << normalizedType(shortestfun->arguments().at(0)->type(), false) << ")'];";
            alias.seek(0);
            signalAliases.append(alias.readAll());
        }
    }
}

static void writeProperty(QTextStream &s, const AbstractMetaClass *meta_class, const QPropertySpec *prop, QMap<QString, QString> &nativeTypes, QSet<QString> &includes)
{
    QString typeName = normalizedType(prop->type()->name());
    QString propName = prop->name();
    QString className = meta_class->name();
    if (className == "QGraphicsObject")
    {
        // JSX can't override property! Now this genertor ignores these properties!
        if (propName == "*")
        {
            propName = "parent";
            return;
        }
        else if (propName == "*effect")
        {
            propName = "effect";
        }
    }
    else if (className == "QAbstractTransition" && propName == "targetStates")
    {
        typeName = "QAbstractAnimation[]";
    }
    else if (className == "QObject" && propName == "parent")
    {
        // JSX can't override property! Now this genertor ignores these properties!
        typeName = "variant";
    }
    QString finalTypeName = nativeTypes.value(typeName, typeName);
    if (skipType(finalTypeName))
    {
        return;
    }
    s << "    var " << propName << " : " << finalTypeName << ";" << endl;
    addIncludeFile(includes, finalTypeName);
}

void JSXGenerator::write(QTextStream &o, const AbstractMetaClass *meta_class)
{
    QMap<QString, QString> nativeTypes;
    nativeTypes["QDateTime"] = "Date";
    nativeTypes["QString"] = "string";
    nativeTypes["QStringRef"] = "string";
    nativeTypes["QChar"] = "string";
    nativeTypes["char"] = "string";
    nativeTypes["intList"] = "int[]";
    nativeTypes["unsigned char"] = "int";
    nativeTypes["signed int"] = "int";
    nativeTypes["signed short"] = "int";
    nativeTypes["unsigned short"] = "int";
    nativeTypes["uchar"] = "int";
    nativeTypes["ushort"] = "int";
    nativeTypes["ulong"] = "int";
    nativeTypes["long"] = "int";
    nativeTypes["short"] = "int";
    nativeTypes["uint"] = "int";
    nativeTypes["uint[]"] = "int[]";
    nativeTypes["qint64"] = "number";
    nativeTypes["unsigned long long"] = "number";
    nativeTypes["qlonglong"] = "number";
    nativeTypes["qulonglong"] = "number";
    nativeTypes["qreal"] = "number";
    nativeTypes["qreal[]"] = "number[]";
    nativeTypes["float"] = "number";
    nativeTypes["double"] = "number";
    nativeTypes["bool"] = "boolean";
    nativeTypes["QStringList"] = "string[]";
    nativeTypes["QRegExp"] = "RegExp";
    nativeTypes["QVariant"] = "variant";
    nativeTypes["QVariant[]"] = "variant[]";
    nativeTypes["void"] = "variant";
    nativeTypes["QUrlList"] = "QUrl[]";
    nativeTypes["QRectFList"] = "QRectF[]";
    nativeTypes["QSslErrorList"] = "QSslError[]";
    nativeTypes["QModelIndexList"] = "QModelIndex[]";
    nativeTypes["Qt_AlignmentFlags"] = "Qt_Alignment";
    nativeTypes["Qt_QAccessible_StateFlags"] = "Qt_QAccessible_State";
    nativeTypes["Qt_QAccessible_RelationFlags"] = "Qt_QAccessible_Relation";
    nativeTypes["Qt_QGraphicsView_CacheModeFlags"] = "Qt_QGraphicsView_CacheMode";
    nativeTypes["Qt_QAbstractSpinBox_StepEnabledFlags"] = "Qt_QAbstractSpinBox_StepEnabled";
    nativeTypes["Qt_QTextEdit_AutoFormattingFlags"] = "Qt_QTextEdit_AutoFormatting";
    nativeTypes["Qt_QUdpSocket_BindFlags"] = "Qt_QUdpSocket_BindMode";
    nativeTypes["Qt_QGLShader_ShaderTypeBits"] = "Qt_QGLShader_ShaderType";
    nativeTypes["Qt_QIODevice_OpenModeFlags"] = "Qt_QIODevice_OpenMode";
    nativeTypes["Qt_QWebPage_ExtensionOption"] = "QWebPage_ExtensionOption";
    nativeTypes["Qt_QWebPage_ExtensionReturn"] = "QWebPage_ExtensionReturn";
    nativeTypes["Qt_QWebPluginFactory_MimeType"] = "QWebPluginFactory_MimeType";
    nativeTypes["Qt_QWebPluginFactory_ExtensionOption"] = "QWebPluginFactory_ExtensionOption";
    nativeTypes["Qt_QWebPluginFactory_ExtensionReturn"] = "QWebPluginFactory_ExtensionReturn";
    nativeTypes["Qt_QWebPluginFactory_Plugin[]"] = "QWebPluginFactory_Plugin[]";
    nativeTypes["Qt_QSql_ParamTypeFlags"] = "Qt_QSql_ParamType";
    nativeTypes["QtMsgType"] = "Qt_Global_QtMsgType";
    nativeTypes["Qt_QTouchEvent_TouchPoint"] = "QTouchEvent_TouchPoint";
    nativeTypes["Qt_QTouchEvent_TouchPoint[]"] = "QTouchEvent_TouchPoint[]";
    nativeTypes["Qt_QPixmapCache_Key"] = "QPixmapCache_Key";
    nativeTypes[QString("const ") + meta_class->name() + " &"] = meta_class->name();

    QSet<QString> methods;
    QSet<QString> includes;

    QString title = meta_class->name();
    title.append(" ");
    if (meta_class->isNamespace())
        title.append("namespace");
    else
        title.append("class");
    writeSourceHeader(o, title);

    QMap<QString, AbstractMetaFunctionList> prototypeFunctions;
    QMap<QString, AbstractMetaFunctionList> staticFunctions;
    QMap<QString, AbstractMetaFunctionList> signalFunctions;
    QMap<QString, AbstractMetaFunctionList> slotFunctions;
    QStringList signalAliases;
    filterFunctions(meta_class, prototypeFunctions, staticFunctions, signalFunctions, slotFunctions);

    QTextStream s("", QIODevice::ReadWrite);

    {
        AbstractMetaEnumList enums = meta_class->enums();
        for (int i = 0; i < enums.size(); ++i) {
            const AbstractMetaEnum *enom = enums.at(i);
            if (shouldIgnoreEnum(enom))
                continue;
            QString classname = meta_class->name();
            if (meta_class->name() != "Qt")
            {
                classname = QString("Qt_") + classname;
            }
            s << "final native class " << classname << "_" << enom->name() << " {}" << endl << endl;
            FlagsTypeEntry *flags = enom->typeEntry()->flags();
            if (flags)
            {
                QString jsxName = classname + "_" + flags->flagsName();
                QString cppName = QString("QFlags<") + meta_class->name() + "::" + enom->name() + ">";
                s << "final native class " << jsxName << " {}" << endl << endl;
                nativeTypes[cppName] = jsxName;
            }
        }
    }

    if (meta_class->baseClass())
    {
        s << "native class " << meta_class->name() << " extends " << meta_class->baseClassName() << endl;
        addIncludeFile(includes, meta_class->baseClassName());
    }
    else if (!meta_class->interfaces().isEmpty())
    {
        AbstractMetaClass *iface = meta_class->interfaces().first();
        AbstractMetaClass *impl = iface->primaryInterfaceImplementor();
        if (impl != meta_class) {
            s << "native class " << meta_class->name() << " extends " << impl->name() << endl;
            addIncludeFile(includes, impl->name());
        } else {
            s << "native class " << meta_class->name() << endl;
        }
    }
    else
    {
        s << "native class " << meta_class->name() << endl;
    }
    s << "{" << endl;

    AbstractMetaFunctionList ctors;
    ctors = meta_class->queryFunctions(AbstractMetaClass::Constructors
                                       | AbstractMetaClass::WasPublic
                                       | AbstractMetaClass::NotRemovedFromTargetLang);

    // Constructor
    if (!ctors.isEmpty()) {
        for (int i = 0; i < ctors.size(); ++i) {
            writeFunction(s, ctors.at(i), nativeTypes, methods, includes);
        }
    }

    {
        if (!staticFunctions.isEmpty()) {
            s << endl;
            s << "    // Static Members" << endl;
            QMap<QString, AbstractMetaFunctionList>::const_iterator it;
            for (it = staticFunctions.constBegin(); it != staticFunctions.constEnd(); ++it) {
                writeFunction(s, it.value().first(), nativeTypes, methods, includes, true);
            }
        }
    }

    {
        AbstractMetaEnumList enums = meta_class->enums();
        for (int i = 0; i < enums.size(); ++i) {
            const AbstractMetaEnum *enom = enums.at(i);
            if (shouldIgnoreEnum(enom))
                continue;
            AbstractMetaEnumValueList values = enom->values();
            QList<int> indexes = uniqueEnumValueIndexes(values);
            s << endl;
            QString enomName = meta_class->name() + "_" + enom->name();
            if (!enomName.startsWith("Qt_")) {
                enomName.insert(0, "Qt_");
            }
            for (int j = 0; j < indexes.size(); ++j) {
                AbstractMetaEnumValue *val = values.at(indexes.at(j));
                s << "    static const " << val->name() << " : " << enomName << ";" << endl;
            }
            s << "    static function " << enom->name() << "(value : " << enomName << ") : " << enomName << ";" << endl;
            nativeTypes[enom->name()] = enomName;
            FlagsTypeEntry *flags = enom->typeEntry()->flags();
            if (flags) {
                QString flagName = meta_class->name() + "_" + flags->flagsName();
                if (!flagName.startsWith("Qt_")) {
                    flagName.insert(0, "Qt_");
                }
                s << "    static function " << flags->flagsName() << "(...value : " << enomName << ") : "
                  << flagName << ";" << endl;
                nativeTypes[flags->flagsName()] = flagName;
            }
        }
    }

    if (!prototypeFunctions.isEmpty()) {
        s << endl;
        s << "    // Methods" << endl;
        QMap<QString, AbstractMetaFunctionList>::const_iterator it;
        for (it = prototypeFunctions.constBegin(); it != prototypeFunctions.constEnd(); ++it) {
            AbstractMetaFunctionList::const_iterator it2;
            for (it2 = it.value().constBegin(); it2 != it.value().constEnd(); ++it2) {
                if (!skipMethod(meta_class, *it2))
                {
                    writeFunction(s, *it2, nativeTypes, methods, includes);
                }
            }
        }
        if (meta_class->name() == "QPainter")
        {
            s << "    function begin (arg__1 : QWidget) : boolean;" << endl;
            includes.insert("qwidget");
        }
    }

    if (!slotFunctions.isEmpty()) {
        s << endl;
        s << "    // Slots" << endl;
        QMap<QString, AbstractMetaFunctionList>::const_iterator it;
        for (it = slotFunctions.constBegin(); it != slotFunctions.constEnd(); ++it) {
            AbstractMetaFunctionList::const_iterator it2;
            for (it2 = it.value().constBegin(); it2 != it.value().constEnd(); ++it2) {
                writeFunction(s, *it2, nativeTypes, methods, includes);
            }
        }
    }

    if (!signalFunctions.isEmpty()) {
        s << endl;
        s << "    // Signals" << endl;
        QMap<QString, AbstractMetaFunctionList>::const_iterator it;
        for (it = signalFunctions.constBegin(); it != signalFunctions.constEnd(); ++it) {
            writeSignal(s, meta_class, it.value(), nativeTypes, _signals, includes, signalAliases);
        }
    }

    if (!meta_class->isNamespace()) {
        QList<QPropertySpec *> props = meta_class->propertySpecs();
        if (!props.isEmpty()) {
            s << endl;
            s << "    // Instance Properties" << endl;
            for (int i = 0; i < props.size(); ++i) {
                if (!skipProperty(meta_class, props.at(i)))
                {
                    writeProperty(s, meta_class, props.at(i), nativeTypes, includes);
                }
            }
        }
    }
    s << "}";
    if (signalAliases.length() == 0)
    {
        s << endl;
    }
    else
    {
        s << " = '''" << meta_class->name() << ";" << endl;
        foreach (const QString &alias, signalAliases) {
            s << alias << endl;
        }
        s << "''';" << endl;
    }

    {
        includes.remove(meta_class->name().toLower());
        includes.remove("int");
        includes.remove("intlist");
        includes.remove("boolean");
        includes.remove("string");
        includes.remove("number");
        includes.remove("variant");
        includes.remove("qlist");
        includes.remove("qvector");
        includes.remove("date");
        includes.remove("regexp");
        QStringList includeFiles = includes.toList();
        qSort(includeFiles.begin(), includeFiles.end());

        foreach (const QString &i, includeFiles) {
            writeInclude(o, i);
        }
        if (!signalFunctions.isEmpty()) {
            writeInclude(o, "_signals");
        }
        o << endl;
    }
    s.seek(0);
    o << s.readAll();
}

